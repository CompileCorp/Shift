# Shift.Ef Development Guide

## Overview

This document covers the development history, bug fixes, and implementation details of the Shift.Ef Entity Framework code generator. It serves as a reference for developers working on or extending the EF generation functionality.

## Development History

### Initial Implementation

The Shift.Ef project was created as a comprehensive Entity Framework code generator that leverages Shift's DatabaseModel infrastructure. The initial implementation included:

- Core code generation classes
- Type mapping system
- Integration with existing Shift functionality
- Basic CLI integration

### DLL Conversion

The project was converted from a standalone executable to a DLL library that integrates with Shift.Cli:

#### Architecture Changes

```
Before:
Shift.Ef (Executable) → Shift

After:
Shift.Ef (DLL) → Shift
     ↑
Shift.Cli → both Shift and Shift.Ef
```

#### Benefits

- **Clean dependency structure** - No circular dependencies
- **Reusable library** - Can be used programmatically
- **Integrated CLI** - Single tool for all Shift operations
- **Maintainable code** - Clear separation of concerns

## Bug Fixes and Improvements

### 1. Auto-Generated Comments

**Issue**: Auto-generated comments were incorrectly added to source code classes.

**Fix**: Removed `// <auto-generated />` comments from all non-generated source files.

**Impact**: Only generated `.g.cs` files now have auto-generated headers.

### 2. Duplicate Column Attributes

**Issue**: Entity classes had duplicate `[Column]` attributes for decimal properties.

**Fix**: Combined Column name and TypeName into single attribute:
```csharp
// Before
[Column("FieldName")]
[Column(TypeName = "decimal(18,2)")]

// After
[Column("FieldName", TypeName = "decimal(18,2)")]
```

**Impact**: Generated entity classes now compile without errors.

### 3. Missing Semicolons in Entity Maps

**Issue**: Property configurations in EntityMap classes were missing semicolons.

**Fix**: Updated EntityMapGenerator to properly terminate property configuration chains:
```csharp
// Before
builder.Property(e => e.Name)
    .HasColumnName("Name")
    .HasColumnType("nvarchar(100)")

// After
builder.Property(e => e.Name)
    .HasColumnName("Name")
    .HasColumnType("nvarchar(100)");
```

**Impact**: Generated EntityMap classes now have valid syntax.

## New Features

### 1. File-Based Model Loading

**Feature**: Added support for generating EF code from file-based models (YAML/JSON).

**Implementation**:
```csharp
// New extension methods
await shift.GenerateEfCodeFromPathAsync(
    paths: new[] { "./Models/User.yaml", "./Models/Order.yaml" },
    outputPath: "./Generated",
    logger: logger,
    options: options
);
```

**Benefits**:
- Support for multiple model formats
- Integration with existing Shift file loading
- Consistent API across all generation methods

### 2. Custom Context Class Names and Base Classes

**Feature**: Added `EfCodeGenerationOptions` class for customization.

**Options Available**:
- `ContextClassName`: Custom name for DbContext class
- `InterfaceName`: Custom name for DbContext interface
- `BaseClassName`: Custom base class to inherit from
- `NamespaceName`: Custom namespace

**Usage**:
```csharp
var options = new EfCodeGenerationOptions
{
    NamespaceName = "MyApp.Data",
    ContextClassName = "MyAppDbContext",
    InterfaceName = "IMyAppDbContext",
    BaseClassName = "MyCustomBaseDbContext"
};
```

### 3. Interface Generation for DbContext

**Feature**: Generates interface versions of DbContext classes.

**Benefits**:
- Better testability with mock interfaces
- Improved dependency injection patterns
- Separation of contract from implementation

**Generated Interface**:
```csharp
public partial interface IMyAppDbContext
{
    DbSet<ClientEntity> Client { get; set; }
    DbSet<OrderEntity> Order { get; set; }
}
```

### 4. Enhanced DbContext Generation

**Feature**: DbContext now implements generated interface and supports inheritance.

**Generated Pattern**:
```csharp
public partial class MyAppDbContext : MyCustomBaseDbContext, IMyAppDbContext
{
    // DbSet properties and configuration
}
```

## Implementation Details

### Code Generation Architecture

#### Modular Design

The code generation system uses a modular approach with separate generators for different components:

- **EfCodeGenerator**: Main orchestrator
- **EntityGenerator**: Entity class generation
- **EntityMapGenerator**: Fluent API configuration generation
- **DbContextGenerator**: DbContext generation
- **DbContextInterfaceGenerator**: Interface generation
- **TypeMapper**: SQL to C# type mapping

#### StringBuilder-Based Generation

All generators use StringBuilder for performance and consistent formatting:

```csharp
public class EntityGenerator
{
    public string GenerateEntity(TableModel table, EfCodeGenerationOptions options)
    {
        var sb = new StringBuilder();
        
        // Generate class header
        sb.AppendLine($"public partial class {table.Name}Entity");
        sb.AppendLine("{");
        
        // Generate properties
        foreach (var field in table.Fields)
        {
            sb.AppendLine($"    {GenerateProperty(field)}");
        }
        
        sb.AppendLine("}");
        return sb.ToString();
    }
}
```

#### Type Mapping System

Comprehensive mapping from SQL Server types to C# types:

```csharp
public class TypeMapper
{
    public string MapToCSharpType(FieldModel field)
    {
        return field.Type switch
        {
            "int" => "int",
            "bigint" => "long",
            "bit" => "bool",
            "nvarchar" => "string",
            "varchar" => "string",
            "datetime" => "DateTime",
            "decimal" => "decimal",
            _ => "object"
        };
    }
}
```

### Integration Strategy

#### Extension Methods

Seamless integration through extension methods:

```csharp
public static class ShiftEfExtensions
{
    public static async Task GenerateEfCodeFromSqlAsync(
        this Shift shift,
        string connectionString,
        string outputPath,
        ILogger logger,
        EfCodeGenerationOptions? options = null)
    {
        var model = await shift.LoadFromSqlAsync(connectionString);
        var generator = new EfCodeGenerator { Logger = logger };
        await generator.GenerateEfCodeAsync(model, outputPath, logger, options);
    }
}
```

#### Logger Integration

Respects Shift's logging infrastructure:

```csharp
public class EfCodeGenerator
{
    public ILogger? Logger { get; set; }
    
    private void LogInfo(string message)
    {
        Logger?.LogInformation(message);
    }
}
```

### File Organization

#### Generated File Naming

- All generated files use `.g.cs` extension
- Custom context class names: `{ContextClassName}.g.cs`
- Interface files: `{InterfaceName}.g.cs`
- Entity files: `{TableName}Entity.g.cs`
- Entity map files: `{TableName}EntityMap.g.cs`

#### Directory Structure

```
Generated/
├── Entities/
│   ├── ClientEntity.g.cs
│   └── OrderEntity.g.cs
├── Maps/
│   ├── ClientEntityMap.g.cs
│   └── OrderEntityMap.g.cs
├── Contexts/
│   ├── MyAppDbContext.g.cs
│   └── IMyAppDbContext.g.cs
└── Extensions/
    └── (for custom extensions)
```

## Testing and Validation

### Build Verification

- All source code compiles without errors
- Generated files have correct syntax
- No duplicate attributes or missing semicolons
- Proper namespace and class name handling

### Functional Testing

- Demo successfully generates sample files
- Generated code includes proper headers and naming
- Entity classes have correct data annotations
- Entity maps use Fluent API correctly
- DbContext includes all entities and configurations

### Code Quality

- Follows .NET coding conventions
- Includes comprehensive XML documentation
- Proper null reference handling
- Type-safe property declarations
- Correct relationship mappings

## Future Enhancements

For planned features, see the [Feature Development Backlog](backlog-features.md).  
For technical debt items, see the [Technical Debt Backlog](backlog-technical-debt.md).

## Development Guidelines

### Code Style

- Follow .NET coding conventions
- Use meaningful variable and method names
- Include XML documentation for public APIs
- Handle null references properly

### Testing

- Write unit tests for all generators
- Test with various database schemas
- Validate generated code compiles
- Test error conditions

### Documentation

- Update documentation with new features
- Include usage examples
- Document breaking changes
- Maintain changelog

### Pull Request Process

1. **Feature Development**
   - Create feature branch
   - Implement with tests
   - Update documentation

2. **Code Review**
   - Review code quality
   - Test functionality
   - Verify documentation

3. **Integration**
   - Merge to main branch
   - Update version numbers
   - Release notes

## Troubleshooting

### Common Development Issues

1. **Type Mapping Problems**
   - Check TypeMapper.cs for missing types
   - Verify SQL type compatibility
   - Test with various data types

2. **Generation Errors**
   - Validate input models
   - Check file permissions
   - Verify output directory exists

3. **Integration Issues**
   - Ensure proper project references
   - Check dependency versions
   - Verify extension method registration

### Debugging Tips

1. **Enable Detailed Logging**
   ```csharp
   var logger = LoggerFactory.Create(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Debug));
   ```

2. **Test with Simple Models**
   - Start with basic entity
   - Add complexity gradually
   - Verify each step

3. **Validate Generated Code**
   - Check compilation
   - Test runtime behavior
   - Verify relationships work
