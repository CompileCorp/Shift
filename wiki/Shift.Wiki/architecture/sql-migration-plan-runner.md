# SqlMigrationPlanRunner Architecture

## Overview

The `SqlMigrationPlanRunner` is a core component of the Shift framework responsible for executing migration plans generated by `MigrationPlanner`. It translates high-level migration steps into SQL statements and executes them against a SQL Server database.

## Purpose and Responsibilities

- **SQL Generation**: Convert migration steps into executable SQL statements
- **Database Execution**: Execute SQL statements against SQL Server databases
- **Error Handling**: Capture and report execution failures
- **Transaction Management**: Execute steps individually (no rollback on failure)
- **Logging**: Provide detailed logging of migration operations

## Architecture

### Core Components

```csharp
public class SqlMigrationPlanRunner
{
    private readonly string _connectionString;
    private readonly MigrationPlan _plan;
    public required ILogger Logger { private get; init; }
    
    public List<(MigrationStep Step, Exception Exception)> Run();
}
```

### Execution Flow

1. **Initialize**: Store connection string and migration plan
2. **Connect**: Establish connection to SQL Server database
3. **Process Steps**: Execute each migration step in order
4. **Generate SQL**: Convert each step to appropriate SQL statements
5. **Execute**: Run SQL statements against the database
6. **Handle Errors**: Capture and report any failures
7. **Return Results**: Return list of failed steps with exceptions

## Supported Migration Actions

### ✅ CreateTable
Creates tables with fields, primary keys, and constraints.

**SQL Generation**:
```sql
CREATE TABLE [TableName] (
  [FieldName] FieldType [CONSTRAINTS],
  CONSTRAINT [PK_TableName] PRIMARY KEY ([PrimaryKeyField])
)
```

**Features**:
- Automatic primary key constraint creation
- Identity column support
- Field type precision and scale handling
- Nullable/not nullable field support

### ✅ AddColumn
Adds new columns to existing tables with smart defaults.

**SQL Generation**:
```sql
ALTER TABLE [TableName] ADD [FieldName] FieldType [CONSTRAINTS] [DEFAULT_VALUE]
```

**Smart Defaults**:
- **Numeric types**: `DEFAULT 0` (or `DEFAULT 1` for ID fields)
- **Boolean types**: `DEFAULT 0`
- **Date types**: `DEFAULT GETDATE()`
- **String types**: `DEFAULT ''`
- **GUID types**: `DEFAULT NEWID()`

**Features**:
- Automatic default constraint removal for nullable columns
- Type-specific default value selection
- Precision and scale support

### ✅ AlterColumn
Modifies existing column definitions (safe widening only).

**SQL Generation**:
```sql
ALTER TABLE [dbo].[TableName] ALTER COLUMN [FieldName] FieldType [CONSTRAINTS]
```

**Safe Widening Rules**:
- `varchar(n)` → `varchar(m)` where m > n
- `nvarchar(n)` → `nvarchar(m)` where m > n
- `varchar(n)` → `varchar(MAX)`
- `binary(n)` → `binary(m)` where m > n
- `varbinary(n)` → `varbinary(m)` where m > n

### ✅ AddForeignKey
Creates foreign key constraints between tables.

**SQL Generation**:
```sql
ALTER TABLE [dbo].[TableName] WITH NOCHECK ADD CONSTRAINT [FK_TableName_ColumnName] 
    FOREIGN KEY ([ColumnName]) REFERENCES [dbo].[TargetTable]([TargetColumnName])

ALTER TABLE [dbo].[TableName] CHECK CONSTRAINT [FK_TableName_ColumnName]
```

**Features**:
- Automatic constraint naming (`FK_TableName_ColumnName`)
- NOCHECK for existing data compatibility
- Two-step process (add constraint, then check)

### ✅ AddIndex
Creates indexes on tables (single or multi-column).

**SQL Generation**:
```sql
CREATE [UNIQUE] INDEX [IX_TableName_Field1_Field2...] ON [dbo].[TableName]([Field1], [Field2], ...)
```

**Features**:
- Automatic index naming (`IX_TableName_Field1_Field2...`)
- Support for unique and non-unique indexes
- Multi-column index support
- Proper column ordering
- Case-insensitive field name matching

**Examples**:
```sql
-- Single column index
CREATE INDEX [IX_User_Email] ON [dbo].[User]([Email])

-- Unique index
CREATE UNIQUE INDEX [IX_User_Username] ON [dbo].[User]([Username])

-- Multi-column index
CREATE INDEX [IX_Order_CustomerID_OrderDate] ON [dbo].[Order]([CustomerID], [OrderDate])

-- Unique multi-column index
CREATE UNIQUE INDEX [IX_Product_SKU_Category] ON [dbo].[Product]([SKU], [Category])
```

## SQL Generation Details

### Naming Conventions

| Object Type | Pattern | Example |
|-------------|---------|---------|
| Primary Key | `PK_TableName` | `PK_User` |
| Foreign Key | `FK_TableName_ColumnName` | `FK_Order_UserID` |
| Index | `IX_TableName_Field1_Field2` | `IX_User_Email_Username` |

### Type Handling

**String Types**:
```sql
-- With precision
nvarchar(256)
varchar(100)

-- With MAX
nvarchar(MAX)
varchar(MAX)
```

**Decimal Types**:
```sql
-- Precision and scale
decimal(10,2)
numeric(18,4)
```

**Binary Types**:
```sql
-- With size
binary(16)
varbinary(MAX)
```

### Default Value Logic

The runner applies intelligent defaults based on field characteristics:

```csharp
// ID fields get DEFAULT 1, others get DEFAULT 0
if (field.Name.EndsWith("ID", StringComparison.OrdinalIgnoreCase))
    defaultSql = " DEFAULT 1";
else
    defaultSql = " DEFAULT 0";
```

## Error Handling

### Failure Model
- **Non-Transactional**: Each step executes independently
- **Continue on Error**: Failed steps don't stop subsequent steps
- **Detailed Reporting**: Returns specific failure information

### Return Format
```csharp
List<(MigrationStep Step, Exception Exception)> failures
```

### Error Types
- **`SqlException`**: Database-specific errors (constraint violations, syntax errors)
- **`Exception`**: General execution errors (connection issues, timeouts)

### Logging
```csharp
// Information level
Logger.LogInformation($"{step.Action} {step.TableName} {details}");

// Debug level  
Logger.LogDebug(sql);

// Error level
Logger.LogError(ex, "{action} failed {sql}", step.Action.ToString(), sql);
```

## Code Examples

### Basic Usage

```csharp
// Create migration plan
var plan = new MigrationPlan();
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.CreateTable,
    TableName = "User",
    Fields = new List<FieldModel>
    {
        new FieldModel { Name = "UserID", Type = "int", IsPrimaryKey = true, IsIdentity = true },
        new FieldModel { Name = "Email", Type = "nvarchar", Precision = 256, IsNullable = false }
    }
});

// Execute migration
var runner = new SqlMigrationPlanRunner(connectionString, plan)
{
    Logger = logger
};

var failures = runner.Run();

// Handle results
if (failures.Any())
{
    foreach (var (step, exception) in failures)
    {
        Console.WriteLine($"Failed: {step.Action} on {step.TableName} - {exception.Message}");
    }
}
```

### Complex Migration

```csharp
var plan = new MigrationPlan();

// Create table
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.CreateTable,
    TableName = "User",
    Fields = new List<FieldModel>
    {
        new FieldModel { Name = "UserID", Type = "int", IsPrimaryKey = true, IsIdentity = true, IsNullable = false },
        new FieldModel { Name = "Email", Type = "nvarchar", Precision = 256, IsNullable = false },
        new FieldModel { Name = "Username", Type = "nvarchar", Precision = 100, IsNullable = false }
    }
});

// Add column
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddColumn,
    TableName = "User",
    Fields = new List<FieldModel>
    {
        new FieldModel { Name = "Phone", Type = "nvarchar", Precision = 20, IsNullable = true }
    }
});

// Add single column unique index
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddIndex,
    TableName = "User",
    Index = new IndexModel
    {
        Fields = new List<string> { "Email" },
        IsUnique = true
    }
});

// Add multi-column index
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddIndex,
    TableName = "Order",
    Index = new IndexModel
    {
        Fields = new List<string> { "CustomerID", "OrderDate" },
        IsUnique = false
    }
});

// Add foreign key
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddForeignKey,
    TableName = "Order",
    ForeignKey = new ForeignKeyModel
    {
        ColumnName = "UserID",
        TargetTable = "User",
        TargetColumnName = "UserID",
        RelationshipType = RelationshipType.ManyToOne
    }
});

var runner = new SqlMigrationPlanRunner(connectionString, plan) { Logger = logger };
var failures = runner.Run();
```

### Integration with MigrationPlanner

```csharp
// Generate migration plan
var migrationPlanner = new MigrationPlanner();
var plan = migrationPlanner.GeneratePlan(targetModel, actualModel);

// Execute migration
var runner = new SqlMigrationPlanRunner(connectionString, plan)
{
    Logger = logger
};

var failures = runner.Run();

// Report results
if (failures.Any())
{
    logger.LogError("Migration completed with {Count} failures", failures.Count);
    foreach (var (step, exception) in failures)
    {
        logger.LogError("Step {Action} on {TableName} failed: {Error}", 
            step.Action, step.TableName, exception.Message);
    }
}
else
{
    logger.LogInformation("Migration completed successfully");
}
```

## Performance Considerations

### Execution Order
- Steps are ordered by `MigrationAction` enum value
- This ensures logical execution order (tables before columns, columns before indexes)
- Custom ordering can be achieved by modifying the enum values

### Connection Management
- Single connection per migration run
- Connection is opened once and reused for all steps
- Connection is properly disposed after completion

### SQL Optimization
- Minimal SQL generation (only necessary statements)
- Efficient constraint naming
- Batch operations where possible

## Limitations

### Not Supported
- **Rollback**: No automatic rollback on failure
- **Transactions**: Steps execute independently
- **Complex Constraints**: Check constraints, computed columns
- **Schema Changes**: Schema modifications beyond table/column operations
- **Data Migration**: No data transformation or migration

### Design Decisions
- **Non-Transactional**: Allows partial success scenarios
- **Continue on Error**: Enables maximum progress through migration plan
- **Simple SQL**: Focuses on common migration scenarios

## Integration Points

### With MigrationPlanner
```csharp
var planner = new MigrationPlanner();
var plan = planner.GeneratePlan(targetModel, actualModel);

var runner = new SqlMigrationPlanRunner(connectionString, plan);
var failures = runner.Run();
```

### With Shift Class
```csharp
var shift = new Shift();
await shift.ApplyMigrationsAsync(connectionString, targetModel);
```

### With Logging
```csharp
var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
var logger = loggerFactory.CreateLogger<SqlMigrationPlanRunner>();

var runner = new SqlMigrationPlanRunner(connectionString, plan)
{
    Logger = logger
};
```

## Testing

### Unit Tests
- Test SQL generation for each action type
- Verify error handling scenarios
- Test edge cases and boundary conditions

### Integration Tests
- Use Docker containers for realistic database testing
- Test complete migration scenarios
- Verify database state after migrations
- Test failure scenarios and recovery

### Test Pattern
```csharp
[Fact]
public async Task Run_WithAddIndexStep_ShouldCreateIndex()
{
    // Arrange
    var databaseName = SqlServerTestHelper.GenerateDatabaseName();
    var connectionString = SqlServerTestHelper.BuildDbConnectionString(containerFixture.ConnectionStringMaster, databaseName);
    
    await SqlServerTestHelper.CreateDatabaseAsync(containerFixture.ConnectionStringMaster, databaseName);
    
    try
    {
        // Create table and migration plan
        // Execute migration
        // Verify results
    }
    finally
    {
        await SqlServerTestHelper.DropDatabaseAsync(containerFixture.ConnectionStringMaster, databaseName);
    }
}
```

The `SqlMigrationPlanRunner` provides a robust, production-ready solution for executing database migrations with comprehensive error handling, logging, and SQL generation capabilities.
