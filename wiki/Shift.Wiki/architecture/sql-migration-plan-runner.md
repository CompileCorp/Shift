# SqlMigrationPlanRunner Architecture

## Overview

The `SqlMigrationPlanRunner` is a core component of the Shift framework responsible for executing migration plans generated by `MigrationPlanner`. It translates high-level migration steps into SQL statements and executes them against a SQL Server database.

## Purpose and Responsibilities

- **SQL Generation**: Convert migration steps into executable SQL statements
- **Database Execution**: Execute SQL statements against SQL Server databases
- **Error Handling**: Capture and report execution failures
- **Transaction Management**: Execute steps individually (no rollback on failure)
- **Logging**: Provide detailed logging of migration operations

## Architecture

### Core Components

```csharp
public class SqlMigrationPlanRunner
{
    private readonly string _connectionString;
    private readonly MigrationPlan _plan;
    public required ILogger Logger { private get; init; }
    
    public List<(MigrationStep Step, Exception Exception)> Run();
}
```

### Execution Flow

1. **Initialize**: Store connection string and migration plan
2. **Connect**: Establish connection to SQL Server database
3. **Process Steps**: Execute each migration step in order
4. **Generate SQL**: Convert each step to appropriate SQL statements
5. **Execute**: Run SQL statements against the database
6. **Handle Errors**: Capture and report any failures
7. **Return Results**: Return list of failed steps with exceptions

## Supported Migration Actions

### ✅ CreateTable
Creates tables with fields, primary keys, and constraints.

**SQL Generation**:
```sql
CREATE TABLE [TableName] (
  [FieldName] FieldType [CONSTRAINTS],
  CONSTRAINT [PK_TableName] PRIMARY KEY ([PrimaryKeyField])
)
```

**Features**:
- Automatic primary key constraint creation
- Identity column support
- Field type precision and scale handling
- Nullable/not nullable field support

### ✅ AddColumn
Adds new columns to existing tables with smart defaults.

**SQL Generation**:
```sql
ALTER TABLE [TableName] ADD [FieldName] FieldType [CONSTRAINTS] [DEFAULT_VALUE]
```

**Smart Defaults**:
- **Numeric types**: `DEFAULT 0` (or `DEFAULT 1` for ID fields)
- **Boolean types**: `DEFAULT 0`
- **Date types**: `DEFAULT GETDATE()`
- **String types**: `DEFAULT ''`
- **GUID types**: `DEFAULT NEWID()`

**Features**:
- Automatic default constraint removal for nullable columns
- Type-specific default value selection
- Precision and scale support

### ✅ AlterColumn
Modifies existing column definitions (safe widening only).

**SQL Generation**:
```sql
ALTER TABLE [dbo].[TableName] ALTER COLUMN [FieldName] FieldType [CONSTRAINTS]
```

**Safe Widening Rules**:
- `varchar(n)` → `varchar(m)` where m > n
- `nvarchar(n)` → `nvarchar(m)` where m > n
- `varchar(n)` → `varchar(MAX)`
- `binary(n)` → `binary(m)` where m > n
- `varbinary(n)` → `varbinary(m)` where m > n

### ✅ AddForeignKey
Creates foreign key constraints between tables and automatically creates an index on the foreign key column.

**SQL Generation**:
```sql
-- Foreign key constraint
ALTER TABLE [dbo].[TableName] WITH NOCHECK ADD CONSTRAINT [FK_TableName_ColumnName] 
    FOREIGN KEY ([ColumnName]) REFERENCES [dbo].[TargetTable]([TargetColumnName])

ALTER TABLE [dbo].[TableName] CHECK CONSTRAINT [FK_TableName_ColumnName]

-- Automatic index on FK column
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_TableName_ColumnName' AND object_id = OBJECT_ID('dbo.TableName'))
BEGIN
    CREATE NONCLUSTERED INDEX [IX_TableName_ColumnName] ON [dbo].[TableName]([ColumnName])
END
```

**Features**:
- Automatic constraint naming (`FK_TableName_ColumnName`)
- NOCHECK for existing data compatibility
- Two-step process (add constraint, then check)
- **Automatic index creation**: A non-clustered, non-unique index is automatically created on every foreign key column
- Index naming follows pattern `IX_TableName_ColumnName`
- Defensive index creation using `IF NOT EXISTS` to prevent duplicate index errors

**Example**:
```sql
-- Adding FK: Order.UserID -> User.UserID
-- Creates both the constraint and an index:

ALTER TABLE [dbo].[Order] WITH NOCHECK ADD CONSTRAINT [FK_Order_UserID] 
    FOREIGN KEY ([UserID]) REFERENCES [dbo].[User]([UserID])

ALTER TABLE [dbo].[Order] CHECK CONSTRAINT [FK_Order_UserID]

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_Order_UserID' AND object_id = OBJECT_ID('dbo.Order'))
BEGIN
    CREATE NONCLUSTERED INDEX [IX_Order_UserID] ON [dbo].[Order]([UserID])
END
```

**Rationale**: Foreign key columns are frequently used in JOIN operations and WHERE clauses. Automatically creating indexes on FK columns improves query performance by optimizing these common access patterns.

### ✅ AddIndex
Creates indexes on tables (single or multi-column) with defensive duplicate handling.

**SQL Generation**:
```sql
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_TableName_Field1_Field2...' AND object_id = OBJECT_ID('dbo.TableName'))
BEGIN
    CREATE [UNIQUE] INDEX [IX_TableName_Field1_Field2...] ON [dbo].[TableName]([Field1], [Field2], ...)
END
```

**Features**:
- **Defensive duplicate handling**: Uses `IF NOT EXISTS` to prevent errors when index already exists
- Automatic index naming (`IX_TableName_Field1_Field2...`)
- Support for unique and non-unique indexes
- Multi-column index support
- Proper column ordering
- Case-insensitive field name matching
- **Model name resolution**: Automatically resolves model names to foreign key column names

**Examples**:
```sql
-- Single column index (defensive)
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_User_Email' AND object_id = OBJECT_ID('dbo.User'))
BEGIN
    CREATE INDEX [IX_User_Email] ON [dbo].[User]([Email])
END

-- Unique index (defensive)
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_User_Username' AND object_id = OBJECT_ID('dbo.User'))
BEGIN
    CREATE UNIQUE INDEX [IX_User_Username] ON [dbo].[User]([Username])
END

-- Multi-column index (defensive)
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_Order_CustomerID_OrderDate' AND object_id = OBJECT_ID('dbo.Order'))
BEGIN
    CREATE INDEX [IX_Order_CustomerID_OrderDate] ON [dbo].[Order]([CustomerID], [OrderDate])
END

-- Unique multi-column index (defensive)
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_Product_SKU_Category' AND object_id = OBJECT_ID('dbo.Product'))
BEGIN
    CREATE UNIQUE INDEX [IX_Product_SKU_Category] ON [dbo].[Product]([SKU], [Category])
END
```

**Model Name Resolution**:
```sql
-- DMD: index (Email, ClientStatus)
-- Resolves to: CREATE INDEX [IX_Client_Email_ClientStatusID] ON [dbo].[Client]([Email], [ClientStatusID])

-- DMD: index (User, OrderDate)  
-- Resolves to: CREATE INDEX [IX_Order_UserID_OrderDate] ON [dbo].[Order]([UserID], [OrderDate])
```

## Index Field Resolution

### IndexFieldResolver Utility

The `SqlMigrationPlanRunner` uses the `IndexFieldResolver` utility class to automatically resolve model names in index definitions to their corresponding foreign key column names.

#### How It Works

1. **Input**: Index field names from DMD files (e.g., `["Email", "ClientStatus"]`)
2. **Resolution**: Model names are mapped to foreign key column names using the table's foreign key relationships
3. **Output**: Resolved field names for SQL generation (e.g., `["Email", "ClientStatusID"]`)

#### Resolution Logic

```csharp
// Build mapping from model names to foreign key column names
var modelToColumnMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

foreach (var fk in table.ForeignKeys)
{
    // Map by TargetTable (model name) to ColumnName (foreign key column name)
    modelToColumnMap[fk.TargetTable] = fk.ColumnName;
}

// Resolve each field name
foreach (var field in fields)
{
    if (modelToColumnMap.TryGetValue(field, out var resolvedName))
    {
        resolvedFields.Add(resolvedName);
    }
    else
    {
        resolvedFields.Add(field); // Use as-is if no mapping found
    }
}
```

#### Examples

| DMD Index Definition          | Foreign Key Relationships         | Resolved SQL Columns |
|-------------------------------|-----------------------------------|---------------------|
| `index (Email, ClientStatus)` | `ClientStatusID` → `ClientStatus` | `[Email], [ClientStatusID]` |
| `index (User, OrderDate)`     | `UserID` → `User`                 | `[UserID], [OrderDate]` |
| `index (Product, Category)`   | `ProductID` → `Product`           | `[ProductID], [Category]` |

#### Edge Cases

- **Case Insensitive**: `"clientstatus"` resolves to `"ClientStatusID"`
- **No Match**: Field names that don't match any foreign key target tables are used as-is
- **Multiple Foreign Keys**: When multiple foreign keys reference the same target table, the last one in the collection is used (due to Dictionary behavior)
- **Mixed Fields**: Regular field names and model names can be mixed in the same index

#### Benefits

- **Maintainable DMD Files**: Use meaningful model names instead of technical column names
- **Automatic Resolution**: No manual mapping required
- **Consistent Naming**: Follows DMD file naming conventions
- **Error Prevention**: Reduces mistakes from manual column name mapping

## SQL Generation Details

### Naming Conventions

| Object Type | Pattern | Example |
|-------------|---------|---------|
| Primary Key | `PK_TableName` | `PK_User` |
| Foreign Key | `FK_TableName_ColumnName` | `FK_Order_UserID` |
| Index | `IX_TableName_Field1_Field2` | `IX_User_Email_Username` |
| Alternate Key | `AK_TableName_Field1_Field2` | `AK_User_Email` |

### Type Handling

**String Types**:
```sql
-- With precision
nvarchar(256)
varchar(100)

-- With MAX
nvarchar(MAX)
varchar(MAX)
```

**Decimal Types**:
```sql
-- Precision and scale
decimal(10,2)
numeric(18,4)
```

**Binary Types**:
```sql
-- With size
binary(16)
varbinary(MAX)
```

### Default Value Logic

The runner applies intelligent defaults based on field characteristics:

```csharp
// ID fields get DEFAULT 1, others get DEFAULT 0
if (field.Name.EndsWith("ID", StringComparison.OrdinalIgnoreCase))
    defaultSql = " DEFAULT 1";
else
    defaultSql = " DEFAULT 0";
```

## Error Handling

### Failure Model
- **Non-Transactional**: Each step executes independently
- **Continue on Error**: Failed steps don't stop subsequent steps
- **Detailed Reporting**: Returns specific failure information
- **Defensive Operations**: Index creation uses `IF NOT EXISTS` to prevent duplicate errors

### Return Format
```csharp
List<(MigrationStep Step, Exception Exception)> failures
```

### Error Types
- **`SqlException`**: Database-specific errors (constraint violations, syntax errors)
- **`Exception`**: General execution errors (connection issues, timeouts)

### Logging
```csharp
// Information level
Logger.LogInformation($"{step.Action} {step.TableName} {details}");

// Debug level  
Logger.LogDebug(sql);

// Error level
Logger.LogError(ex, "{action} failed {sql}", step.Action.ToString(), sql);
```

## Code Examples

### Basic Usage

```csharp
// Create migration plan
var plan = new MigrationPlan();
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.CreateTable,
    TableName = "User",
    Fields = new List<FieldModel>
    {
        new FieldModel { Name = "UserID", Type = "int", IsPrimaryKey = true, IsIdentity = true },
        new FieldModel { Name = "Email", Type = "nvarchar", Precision = 256, IsNullable = false }
    }
});

// Execute migration
var runner = new SqlMigrationPlanRunner(connectionString, plan)
{
    Logger = logger
};

var failures = runner.Run();

// Handle results
if (failures.Any())
{
    foreach (var (step, exception) in failures)
    {
        Console.WriteLine($"Failed: {step.Action} on {step.TableName} - {exception.Message}");
    }
}
```

### Complex Migration

```csharp
var plan = new MigrationPlan();

// Create table
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.CreateTable,
    TableName = "User",
    Fields = new List<FieldModel>
    {
        new FieldModel { Name = "UserID", Type = "int", IsPrimaryKey = true, IsIdentity = true, IsNullable = false },
        new FieldModel { Name = "Email", Type = "nvarchar", Precision = 256, IsNullable = false },
        new FieldModel { Name = "Username", Type = "nvarchar", Precision = 100, IsNullable = false }
    }
});

// Add column
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddColumn,
    TableName = "User",
    Fields = new List<FieldModel>
    {
        new FieldModel { Name = "Phone", Type = "nvarchar", Precision = 20, IsNullable = true }
    }
});

// Add single column unique index
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddIndex,
    TableName = "User",
    Index = new IndexModel
    {
        Fields = new List<string> { "Email" },
        IsUnique = true
    }
});

// Add multi-column index
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddIndex,
    TableName = "Order",
    Index = new IndexModel
    {
        Fields = new List<string> { "CustomerID", "OrderDate" },
        IsUnique = false
    }
});

// Add foreign key
plan.Steps.Add(new MigrationStep
{
    Action = MigrationAction.AddForeignKey,
    TableName = "Order",
    ForeignKey = new ForeignKeyModel
    {
        ColumnName = "UserID",
        TargetTable = "User",
        TargetColumnName = "UserID",
        RelationshipType = RelationshipType.ManyToOne
    }
});

var runner = new SqlMigrationPlanRunner(connectionString, plan) { Logger = logger };
var failures = runner.Run();
```

### Integration with MigrationPlanner

```csharp
// Generate migration plan
var migrationPlanner = new MigrationPlanner();
var plan = migrationPlanner.GeneratePlan(targetModel, actualModel);

// Execute migration
var runner = new SqlMigrationPlanRunner(connectionString, plan)
{
    Logger = logger
};

var failures = runner.Run();

// Report results
if (failures.Any())
{
    logger.LogError("Migration completed with {Count} failures", failures.Count);
    foreach (var (step, exception) in failures)
    {
        logger.LogError("Step {Action} on {TableName} failed: {Error}", 
            step.Action, step.TableName, exception.Message);
    }
}
else
{
    logger.LogInformation("Migration completed successfully");
}
```

## Performance Considerations

### Execution Order
- Steps are ordered by `MigrationAction` enum value
- This ensures logical execution order (tables before columns, columns before indexes)
- Custom ordering can be achieved by modifying the enum values

### Connection Management
- Single connection per migration run
- Connection is opened once and reused for all steps
- Connection is properly disposed after completion

### SQL Optimization
- Minimal SQL generation (only necessary statements)
- Efficient constraint naming
- Batch operations where possible

## Limitations

### Not Supported
- **Rollback**: No automatic rollback on failure
- **Transactions**: Steps execute independently
- **Complex Constraints**: Check constraints, computed columns
- **Schema Changes**: Schema modifications beyond table/column operations
- **Data Migration**: No data transformation or migration

### Design Decisions
- **Non-Transactional**: Allows partial success scenarios
- **Continue on Error**: Enables maximum progress through migration plan
- **Simple SQL**: Focuses on common migration scenarios

## Integration Points

### With MigrationPlanner
```csharp
var planner = new MigrationPlanner();
var plan = planner.GeneratePlan(targetModel, actualModel);

var runner = new SqlMigrationPlanRunner(connectionString, plan);
var failures = runner.Run();
```

### With Shift Class
```csharp
var shift = new Shift();
await shift.ApplyMigrationsAsync(connectionString, targetModel);
```

### With Logging
```csharp
var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
var logger = loggerFactory.CreateLogger<SqlMigrationPlanRunner>();

var runner = new SqlMigrationPlanRunner(connectionString, plan)
{
    Logger = logger
};
```

## Testing

### Unit Tests
- Test SQL generation for each action type
- Verify error handling scenarios
- Test edge cases and boundary conditions

### Integration Tests
- Use Docker containers for realistic database testing
- Test complete migration scenarios
- Verify database state after migrations
- Test failure scenarios and recovery

### Test Pattern
```csharp
[Fact]
public async Task Run_WithAddIndexStep_ShouldCreateIndex()
{
    // Arrange
    var databaseName = SqlServerTestHelper.GenerateDatabaseName();
    var connectionString = SqlServerTestHelper.BuildDbConnectionString(containerFixture.ConnectionStringMaster, databaseName);
    
    await SqlServerTestHelper.CreateDatabaseAsync(containerFixture.ConnectionStringMaster, databaseName);
    
    try
    {
        // Create table and migration plan
        // Execute migration
        // Verify results
    }
    finally
    {
        await SqlServerTestHelper.DropDatabaseAsync(containerFixture.ConnectionStringMaster, databaseName);
    }
}
```

The `SqlMigrationPlanRunner` provides a robust, production-ready solution for executing database migrations with comprehensive error handling, logging, and SQL generation capabilities.
